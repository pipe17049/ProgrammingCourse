"""
‚ö†Ô∏è SESI√ìN 1.3: Race Conditions - Los Peligros de la Concurrencia

Este m√≥dulo demuestra los problemas que surgen cuando m√∫ltiples threads
acceden a recursos compartidos sin sincronizaci√≥n adecuada.

üéØ Objetivos:
- Entender qu√© son las race conditions
- Ver ejemplos pr√°cticos de data corruption
- Identificar problemas de concurrencia
- Preparar para soluciones con locks
"""

import time
import threading
from typing import List

# ============================================================================
# ‚ö†Ô∏è PROBLEMA 1: Contador Global Sin Protecci√≥n
# ============================================================================

# Variable global compartida (¬°PELIGRO!)
unsafe_counter = 0

def increment_unsafe(thread_id: int, increments: int):
    """‚ö†Ô∏è PELIGROSO: Incrementa contador sin protecci√≥n"""
    global unsafe_counter
    
    print(f"üßµ Thread {thread_id}: Iniciando {increments} incrementos")
    
    for i in range(increments):
        # ‚ö†Ô∏è RACE CONDITION: Multiple threads leyendo/escribiendo la misma variable
        current_value = unsafe_counter  # Lee valor actual
        # leimos 5000
        # Simular algo de procesamiento (hace el problema m√°s visible)
        time.sleep(0.00001)  # 10 microsegundos
        # otro tread sumo 5000 => 10000  ; 10000 => 5001
        new_value = current_value + 1   # Calcula nuevo valor
        unsafe_counter = new_value      # Escribe nuevo valor
        
        if i % 1000 == 0:  # Progress cada 1000 incrementos
            print(f"üßµ Thread {thread_id}: Progress {i}/{increments}, counter={unsafe_counter}")
    
    print(f"‚úÖ Thread {thread_id}: Completado")

def demonstrate_race_condition():
    """‚ö†Ô∏è DEMOSTRACI√ìN: Race condition en acci√≥n"""
    global unsafe_counter
    
    print("\n" + "‚ö†Ô∏è " + "="*60)
    print("‚ö†Ô∏è DEMOSTRACI√ìN: Race Condition - Contador Inseguro")
    print("="*60)
    
    # Reset counter
    unsafe_counter = 0
    
    # Configuraci√≥n
    num_threads = 5
    increments_per_thread = 5000
    expected_total = num_threads * increments_per_thread
    
    print(f"üéØ Configuraci√≥n:")
    print(f"   - Threads: {num_threads}")
    print(f"   - Incrementos por thread: {increments_per_thread}")
    print(f"   - Total esperado: {expected_total}")
    
    # Crear y lanzar threads
    threads = []
    start_time = time.time()
    
    for i in range(num_threads):
        thread = threading.Thread(
            target=increment_unsafe,
            args=(i+1, increments_per_thread)
        )
        threads.append(thread)
        thread.start()
    
    # Esperar que terminen
    for thread in threads:
        thread.join()
    
    end_time = time.time()
    
    # üìä AN√ÅLISIS DE RESULTADOS
    print(f"\nüìä RESULTADOS:")
    print(f"   üéØ Esperado: {expected_total}")
    print(f"   üí• Obtenido: {unsafe_counter}")
    print(f"   ‚ùå Diferencia: {expected_total - unsafe_counter}")
    print(f"   ‚è±Ô∏è Tiempo: {end_time - start_time:.2f} segundos")
    
    if unsafe_counter != expected_total:
        print(f"\n‚ö†Ô∏è ¬°RACE CONDITION DETECTADA!")
        print(f"‚ö†Ô∏è Se perdieron {expected_total - unsafe_counter} incrementos")
        print(f"‚ö†Ô∏è Esto ocurre cuando threads interfieren entre s√≠")
    else:
        print(f"\nü§î No se detect√≥ race condition en esta ejecuci√≥n")
        print(f"ü§î (Puede ocurrir por casualidad - ejecuta varias veces)")
    
    return unsafe_counter

# ============================================================================
# ‚ö†Ô∏è PROBLEMA 2: Lista Compartida Sin Protecci√≥n
# ============================================================================

# ‚ö†Ô∏è Variable global compartida (PELIGROSA)
shared_list = []

def add_items_unsafe(thread_id: int, items_count: int):
    global shared_list
    
    for i in range(items_count):
        # ‚ö†Ô∏è RACE CONDITION: "Read-Copy-Replace" EXTREMADAMENTE peligroso
        
        # STEP 1: Read current list (snapshot)
        current_snapshot = shared_list[:]  # Create copy
        current_length = len(current_snapshot)
        
        # STEP 2: Vulnerability window - otros threads pueden modificar shared_list
        time.sleep(0.0001)  # Critical section sin protecci√≥n
        
        # STEP 3: Modify the copy (basado en snapshot "stale")
        new_item = f"Thread-{thread_id}-Item-{i}"
        current_snapshot.append(new_item)
        
        # STEP 4: Replace entire list with modified copy (DANGEROUS!)
        # ¬°Si otro thread modific√≥ shared_list, esos cambios se pierden!
        shared_list = current_snapshot  # üí• DESTRUCTIVE WRITE
        
        if i % 500 == 0:
            print(f"üßµ Thread {thread_id}: Agregados {i}/{items_count}, lista tiene {len(shared_list)} items")
    
    print(f"‚úÖ Thread {thread_id}: Completado, lista final: {len(shared_list)} items")

def demonstrate_list_race_condition():
    """‚ö†Ô∏è DEMOSTRACI√ìN: Race condition con lista compartida"""
    global shared_list
    
    print("\n" + "‚ö†Ô∏è " + "="*60)
    print("‚ö†Ô∏è DEMOSTRACI√ìN: Race Condition - Lista Compartida")
    print("="*60)
    
    # Reset lista
    shared_list = []
    
    # Configuraci√≥n
    num_threads = 4
    items_per_thread = 2000
    expected_total = num_threads * items_per_thread
    
    print(f"üéØ Configuraci√≥n:")
    print(f"   - Threads: {num_threads}")
    print(f"   - Items por thread: {items_per_thread}")
    print(f"   - Total esperado: {expected_total}")
    
    # Crear y lanzar threads
    threads = []
    start_time = time.time()
    
    for i in range(num_threads):
        thread = threading.Thread(
            target=add_items_unsafe,
            args=(i+1, items_per_thread)
        )
        threads.append(thread)
        thread.start()
    
    # Esperar que terminen
    for thread in threads:
        thread.join()
    
    end_time = time.time()
    
    # üìä AN√ÅLISIS DE RESULTADOS
    actual_total = len(shared_list)
    
    print(f"\nüìä RESULTADOS:")
    print(f"   üéØ Esperado: {expected_total} items")
    print(f"   üí• Obtenido: {actual_total} items")
    print(f"   ‚ùå Diferencia: {expected_total - actual_total}")
    print(f"   ‚è±Ô∏è Tiempo: {end_time - start_time:.2f} segundos")
    
    if actual_total != expected_total:
        print(f"\n‚ö†Ô∏è ¬°RACE CONDITION EN LISTA DETECTADA!")
        print(f"‚ö†Ô∏è Posible corrupci√≥n de datos o items perdidos")
    
    return actual_total

# ============================================================================
# ‚ö†Ô∏è PROBLEMA 3: Cuenta Bancaria Insegura
# ============================================================================

class UnsafeBankAccount:
    """‚ö†Ô∏è PELIGROSO: Cuenta bancaria sin protecci√≥n para transacciones"""
    
    def __init__(self, initial_balance: float = 1000.0):
        self.balance = initial_balance
        self.transaction_history = []
    
    def deposit(self, amount: float, thread_id: int):
        """‚ö†Ô∏è PELIGROSO: Dep√≥sito sin protecci√≥n"""
        print(f"üí∞ Thread {thread_id}: Depositando ${amount}")
        
        # ‚ö†Ô∏è RACE CONDITION: Lectura y escritura no at√≥mica
        current_balance = self.balance
        
        # Simular procesamiento de transacci√≥n
        time.sleep(0.001)  # 1ms - simula verificaci√≥n, etc.
        
        new_balance = current_balance + amount
        self.balance = new_balance
        
        # ‚ö†Ô∏è RACE CONDITION: Lista tambi√©n sin protecci√≥n
        transaction = {
            'type': 'deposit',
            'amount': amount,
            'balance_after': new_balance,
            'thread': thread_id,
            'timestamp': time.time()
        }
        self.transaction_history.append(transaction)
        
        print(f"‚úÖ Thread {thread_id}: Dep√≥sito completado, balance: ${self.balance:.2f}")
    
    def withdraw(self, amount: float, thread_id: int):
        """‚ö†Ô∏è PELIGROSO: Retiro sin protecci√≥n"""
        print(f"üí∏ Thread {thread_id}: Retirando ${amount}")
        
        # ‚ö†Ô∏è RACE CONDITION: Verificaci√≥n y modificaci√≥n no at√≥mica
        current_balance = self.balance
        
        if current_balance >= amount:
            # Simular procesamiento
            time.sleep(0.001)
            
            new_balance = current_balance - amount
            self.balance = new_balance
            
            transaction = {
                'type': 'withdrawal',
                'amount': amount,
                'balance_after': new_balance,
                'thread': thread_id,
                'timestamp': time.time()
            }
            self.transaction_history.append(transaction)
            
            print(f"‚úÖ Thread {thread_id}: Retiro completado, balance: ${self.balance:.2f}")
        else:
            print(f"‚ùå Thread {thread_id}: Fondos insuficientes para retirar ${amount}")

def banking_thread(account: UnsafeBankAccount, thread_id: int, transactions: int):
    """Simula transacciones bancarias concurrentes con valores FIJOS para claridad"""
    print(f"üè¶ Thread {thread_id}: Iniciando {transactions} transacciones")
    
    # Valores fijos predecibles por thread
    deposit_amounts = {
        1: [100.0, 50.0, 75.0],  # Thread 1: dep√≥sitos
        2: [25.0, 30.0, 20.0],   # Thread 2: dep√≥sitos  
        3: [40.0, 60.0, 35.0],   # Thread 3: dep√≥sitos
    }
    
    withdraw_amounts = {
        1: [10.0, 15.0, 5.0],    # Thread 1: retiros
        2: [20.0, 25.0, 10.0],   # Thread 2: retiros
        3: [30.0, 35.0, 15.0],   # Thread 3: retiros  
    }
    
    for i in range(transactions):
        transaction_num = i % 3  # Usar √≠ndice para valores fijos
        
        # Alternar entre dep√≥sitos y retiros de forma predecible
        if i % 2 == 0:  # Pares = dep√≥sito
            amount = deposit_amounts[thread_id][transaction_num]
            print(f"üí∞ Thread {thread_id}: Depositando ${amount:.2f} (transacci√≥n {i+1})")
            account.deposit(amount, thread_id)
        else:  # Impares = retiro
            amount = withdraw_amounts[thread_id][transaction_num]
            print(f"üí∏ Thread {thread_id}: Retirando ${amount:.2f} (transacci√≥n {i+1})")
            account.withdraw(amount, thread_id)
        
        # Peque√±a pausa entre transacciones
        time.sleep(0.001)  # M√°s tiempo para hacer race condition m√°s visible
    
    print(f"üè¶ Thread {thread_id}: Transacciones completadas")

def demonstrate_banking_race_condition():
    """‚ö†Ô∏è DEMOSTRACI√ìN: Race condition en transacciones bancarias"""
    print("\n" + "‚ö†Ô∏è " + "="*60)
    print("‚ö†Ô∏è DEMOSTRACI√ìN: Race Condition - Transacciones Bancarias")
    print("="*60)
    
    # Crear cuenta
    initial_balance = 1000.0
    account = UnsafeBankAccount(initial_balance)
    
    print(f"üè¶ Balance inicial: ${account.balance:.2f}")
    
    # Configuraci√≥n
    num_threads = 3
    transactions_per_thread = 6  # 6 transacciones con valores fijos predecibles
    
    print(f"üéØ Configuraci√≥n:")
    print(f"   - Threads: {num_threads}")
    print(f"   - Transacciones por thread: {transactions_per_thread}")
    
    print(f"\nüí∞ TRANSACCIONES PLANIFICADAS (valores fijos):")
    print("Thread 1: +$100, -$10, +$50, -$15, +$75, -$5   (neto: +$195)")
    print("Thread 2: +$25,  -$20, +$30, -$25, +$20, -$10  (neto: +$20)")
    print("Thread 3: +$40,  -$30, +$60, -$35, +$35, -$15  (neto: +$55)")
    print(f"Balance esperado SIN race conditions: $1000 + $270 = $1270")
    # Mostrar tambi√©n el balance te√≥rico y el real despu√©s de la ejecuci√≥n
    # (esto se imprime despu√©s en la funci√≥n, pero aqu√≠ lo dejamos claro)
    # El balance te√≥rico se calcula m√°s abajo, pero aqu√≠ recordamos el esperado
    # para que el usuario compare f√°cilmente.
    # El balance te√≥rico y el real pueden diferir del esperado si hay race conditions.
    
    # Lanzar threads concurrentes
    threads = []
    start_time = time.time()
    
    for i in range(num_threads):
        thread = threading.Thread(
            target=banking_thread,
            args=(account, i+1, transactions_per_thread)
        )
        threads.append(thread)
        thread.start()
    
    # Esperar que terminen
    for thread in threads:
        thread.join()
    
    end_time = time.time()
    
    # üìä AN√ÅLISIS DE RESULTADOS
    print(f"\nüìä RESULTADOS:")
    print(f"   üí∞ Balance inicial: ${initial_balance:.2f}")
    print(f"   üí∞ Balance final: ${account.balance:.2f}")
    print(f"   üìú Transacciones registradas: {len(account.transaction_history)}")
    print(f"   ‚è±Ô∏è Tiempo: {end_time - start_time:.2f} segundos")
    
    # Calcular balance te√≥rico basado en transacciones
    theoretical_balance = initial_balance
    for transaction in account.transaction_history:
        if transaction['type'] == 'deposit':
            theoretical_balance += transaction['amount']
        else:
            theoretical_balance -= transaction['amount']
    
    print(f"   üßÆ Balance te√≥rico: ${theoretical_balance:.2f}")
    
    difference = abs(account.balance - theoretical_balance)
    if difference > 0.01:  # Permitir peque√±os errores de punto flotante
        print(f"\n‚ö†Ô∏è ¬°INCONSISTENCIA DETECTADA!")
        print(f"‚ö†Ô∏è Diferencia: ${difference:.2f}")
        print(f"‚ö†Ô∏è Posible corrupci√≥n por race conditions")
    else:
        print(f"\n‚úÖ Balance consistente (por casualidad)")
    
    return account

# ============================================================================
# üéì CONCEPTOS Y CAUSAS DE RACE CONDITIONS
# ============================================================================

def explain_race_conditions():
    """Explicar qu√© son las race conditions y por qu√© ocurren"""
    print("\n" + "üéì" + "="*60)
    print("üéì ENTENDIENDO LAS RACE CONDITIONS")
    print("="*60)
    
    explanations = [
        ("¬øQu√© es una Race Condition?", 
         "Cuando el resultado depende del timing impredecible de threads"),
        
        ("¬øPor qu√© ocurren?", 
         "Operaciones no-at√≥micas en recursos compartidos"),
        
        ("Read-Modify-Write", 
         "Secuencia vulnerable: leer ‚Üí modificar ‚Üí escribir"),
        
        ("Context Switching", 
         "El OS puede cambiar de thread en cualquier momento"),
        
        ("Visibilidad de Memoria", 
         "Cambios de un thread pueden no ser visibles inmediatamente"),
        
        ("Lost Updates", 
         "Modificaciones se pierden cuando threads sobrescriben"),
        
        ("Data Corruption", 
         "Estructuras de datos quedan en estado inconsistente"),
        
        ("Non-Deterministic", 
         "Resultado diferente en cada ejecuci√≥n")
    ]
    
    for concept, explanation in explanations:
        print(f"üí° {concept:20}: {explanation}")
    
    print(f"\nüö® SIGNOS DE RACE CONDITIONS:")
    print(f"‚ùå Resultados diferentes en cada ejecuci√≥n")
    print(f"‚ùå Datos 'perdidos' o incorrectos")
    print(f"‚ùå Inconsistencias en estructuras de datos")
    print(f"‚ùå Comportamiento impredecible")
    print(f"‚ùå Errores que aparecen/desaparecen")
    
    print(f"\nüí° PR√ìXIMA SOLUCI√ìN: ¬°LOCKS y SINCRONIZACI√ìN!")

# ============================================================================
# üß™ EJECUTAR TODAS LAS DEMOSTRACIONES
# ============================================================================

def run_all_race_condition_demos():
    """Ejecutar todas las demostraciones de race conditions"""
    print("‚ö†Ô∏è EJECUTANDO TODAS LAS DEMOSTRACIONES DE RACE CONDITIONS")
    print("üéØ Objetivo: Ver problemas antes de aprender soluciones")
    
    # Demo 1: Contador
    counter_result = demonstrate_race_condition()
    
    # Demo 2: Lista
    list_result = demonstrate_list_race_condition()
    
    # Demo 3: Cuenta bancaria
    account_result = demonstrate_banking_race_condition()
    
    # Explicaci√≥n
    explain_race_conditions()
    
    return {
        'counter': counter_result,
        'list_length': list_result,
        'account': account_result
    }

if __name__ == "__main__":
    print("‚ö†Ô∏è DEMOSTRACI√ìN: Race Conditions y Problemas de Concurrencia")
    print("üéØ IMPORTANTE: Estos son ejemplos de lo que NO debes hacer")
    
    print("\nü§î ¬øQuieres ver todas las demostraciones? (y/n)")
    choice = input("üëâ ").lower().strip()
    
    if choice in ['y', 'yes', 's√≠', 's']:
        results = run_all_race_condition_demos()
        print(f"\nüìä Resumen de problemas encontrados:")
        print(f"   - Contador: {results['counter']} (puede estar incorrecto)")
        print(f"   - Lista: {results['list_length']} items (puede estar incorrecto)")
        print(f"   - Cuenta: ${results['account'].balance:.2f} (puede estar inconsistente)")
    else:
        # Solo una demo r√°pida
        print("\n‚ö†Ô∏è Demo r√°pida: Contador inseguro")
        demonstrate_race_condition()
    
    print("\n‚ö†Ô∏è Estos problemas son REALES en aplicaciones de producci√≥n")
    print("üí° La soluci√≥n: Sincronizaci√≥n con LOCKS")
    print("üöÄ Pr√≥ximo paso: 04_locks_solution.py")